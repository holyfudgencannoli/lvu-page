<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cloudflare R2 Multipart Upload</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 600px;
      margin: 3rem auto;
      padding: 1rem;
    }
    .progress {
      width: 100%;
      height: 16px;
      background: #eee;
      border-radius: 8px;
      overflow: hidden;
      margin-top: 1rem;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: #007aff;
      transition: width 0.2s;
    }
    #status {
      margin-top: 1rem;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <h1>Upload Video to R2</h1>
  <input type="file" id="fileInput" accept="video/*" />
  <button id="uploadBtn">Upload</button>
  
  <div class="progress"><div class="progress-bar" id="progressBar"></div></div>
  <div id="status"></div>

  <script>
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    const progressBar = document.getElementById("progressBar");
    const status = document.getElementById("status");
    const API_BASE = "https://upload-api.<your-subdomain>.workers.dev";


    uploadBtn.addEventListener("click", async () => {
      const file = fileInput.files?.[0];
      if (!file) {
        alert("Please choose a file first.");
        return;
      }

      status.textContent = "Initializing upload...";
      progressBar.style.width = "0%";

      try {
        // 1️⃣ Start multipart upload
        const initRes = await fetch(`${API_BASE}/initiate`);
        const { uploadId, key } = await initRes.json();

        const CHUNK_SIZE = 10 * 1024 * 1024; // 10 MB
        const totalParts = Math.ceil(file.size / CHUNK_SIZE);
        const parts = [];

        for (let i = 0; i < totalParts; i++) {
          const start = i * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, file.size);
          const blobPart = file.slice(start, end);
          const partNumber = i + 1;

          // 2️⃣ Get signed URL for this part
          const signRes = await fetch(
            `${API_BASE}/sign-part?key=${key}&uploadId=${uploadId}&partNumber=${partNumber}`
          );
          const { signedUrl } = await signRes.json();

          // 3️⃣ Upload chunk directly to R2
          const xhr = new XMLHttpRequest();
          xhr.open("PUT", signedUrl, true);

          xhr.upload.onprogress = (event) => {
            if (event.lengthComputable) {
              const partProgress = ((i + event.loaded / event.total) / totalParts) * 100;
              progressBar.style.width = `${partProgress.toFixed(2)}%`;
            }
          };

          await new Promise((resolve, reject) => {
            xhr.onload = () => {
              if (xhr.status >= 200 && xhr.status < 300) {
                const etag = xhr.getResponseHeader("ETag").replace(/"/g, "");
                parts.push({ etag, partNumber });
                resolve();
              } else {
                reject(new Error(`Part ${partNumber} failed`));
              }
            };
            xhr.onerror = reject;
            xhr.send(blobPart);
          });
        }

        // 4️⃣ Complete upload
        status.textContent = "Finalizing...";
        const completeRes = await fetch(`${API_BASE}/complete`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ key, uploadId, parts }),
        });

        if (completeRes.ok) {
          const data = await completeRes.json();
          status.textContent = `✅ Upload complete! File stored at: ${data.location || key}`;
          progressBar.style.width = "100%";
        } else {
          status.textContent = "❌ Upload failed during completion step.";
        }
      } catch (err) {
        console.error(err);
        status.textContent = "❌ Upload failed: " + err.message;
      }
    });
  </script>
</body>
</html>
